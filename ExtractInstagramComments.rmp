<?xml version="1.0" encoding="UTF-8"?><process version="9.7.002">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="9.7.002" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="SYSTEM"/>
    <process expanded="true">
      <operator activated="true" class="set_macro" compatibility="9.7.002" expanded="true" height="82" name="Postcode from URL" width="90" x="45" y="34">
        <parameter key="macro" value="postcode"/>
        <parameter key="value" value="CQrZLTpJatS"/>
      </operator>
      <operator activated="true" class="set_macro" compatibility="9.7.002" expanded="true" height="82" name="Username" width="90" x="45" y="136">
        <parameter key="macro" value="user"/>
      </operator>
      <operator activated="true" class="set_macro" compatibility="9.7.002" expanded="true" height="82" name="Password" width="90" x="45" y="238">
        <parameter key="macro" value="pass"/>
        <parameter key="value" value="Starwars9"/>
      </operator>
      <operator activated="true" class="set_macro" compatibility="9.7.002" expanded="true" height="82" name="Amount of Comments to download" width="90" x="45" y="340">
        <parameter key="macro" value="amount"/>
        <parameter key="value" value="50"/>
      </operator>
      <operator activated="true" class="set_macro" compatibility="9.7.002" expanded="true" height="82" name="Language of Emoji Translations" width="90" x="45" y="442">
        <parameter key="macro" value="lang"/>
        <description align="center" color="transparent" colored="false" width="126">de = german&lt;br&gt;en = english&lt;br&gt;specifies the language in which the emojis should be translated to.&lt;br/&gt;&lt;br/&gt;if empty they stay as emojis&lt;br/&gt;&lt;br&gt;</description>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="9.7.001" expanded="true" height="187" name="Execute Python" width="90" x="179" y="187">
        <parameter key="script" value="import pandas as pd&#10;import time&#10;import requests&#10;from requests_html import HTMLSession&#10;import re&#10;import json&#10;import hashlib&#10;import os&#10;from slugify import slugify&#10;import http.cookiejar&#10;import http.cookiejar&#10;import textwrap&#10;import urllib.parse&#10;import pandas as pd&#10;from emoji import unicode_codes&#10;import re&#10;_EMOJI_REGEXP = None&#10;def rm_main(macros):&#10; &#10;    BASE_URL = 'https://www.instagram.com'&#10;    LOGIN_URL = 'https://www.instagram.com/accounts/login/ajax/'&#10;    MEDIA_LINK = 'https://www.instagram.com/p/%s'&#10;    COMMENTS_BEFORE_COMMENT_ID_BY_CODE = 'https://www.instagram.com/graphql/query/?query_hash=97b41c52301f77ce508f55e66d17620e&amp;variables=%s'&#10;&#10;    _DEFAULT_DELIMITER = ':'&#10;    &#10;&#10;    def get_emoji_regexp(language='en'):&#10;        global _EMOJI_REGEXP&#10;        EMOJI_UNICODE = unicode_codes.EMOJI_UNICODE[language]&#10;        if _EMOJI_REGEXP is None:&#10;            emojis = sorted(EMOJI_UNICODE.values(), key=len, reverse=True)&#10;            pattern = u'(' + u'|'.join(re.escape(u) for u in emojis) + u')'&#10;            _EMOJI_REGEXP = re.compile(pattern)&#10;        return _EMOJI_REGEXP&#10;&#10;    def demojize(string,language,use_aliases=False,delimiters=(_DEFAULT_DELIMITER, _DEFAULT_DELIMITER)):&#10;        UNICODE_EMOJI = unicode_codes.UNICODE_EMOJI[language]&#10;        def replace(match):&#10;            codes_dict = unicode_codes.UNICODE_EMOJI_ALIAS_ENGLISH if use_aliases else UNICODE_EMOJI&#10;            val = codes_dict.get(match.group(0), match.group(0))&#10;            return delimiters[0] + val[1:-1] + delimiters[1]&#10;        return re.sub(u'\ufe0f', '', (get_emoji_regexp(language).sub(replace, string)))&#10;        &#10;    def get_media_page_link(code):&#10;        return MEDIA_LINK % urllib.parse.quote_plus(code)&#10;&#10;    def get_comments_before_comments_id_by_code(variables):&#10;        return COMMENTS_BEFORE_COMMENT_ID_BY_CODE % urllib.parse.quote_plus(json.dumps(variables, separators=(',', ':')))&#10;        &#10;    class InstagramException(Exception):&#10;        def __init__(self, message=&quot;&quot;, code=500):&#10;            super().__init__(f'{message}, Code:{code}')&#10;        &#10;        @staticmethod&#10;        def default(response_text, status_code):&#10;            return InstagramException(&#10;                'Response code is {status_code}. Body: {response_text} '&#10;                'Something went wrong. Please report issue.'.format(&#10;                    response_text=response_text, status_code=status_code),&#10;                status_code)&#10;&#10;    class CookieSessionManager:&#10;        def __init__(self, session_folder, filename):&#10;            self.session_folder = session_folder&#10;            self.filename = filename&#10;&#10;        def get_saved_cookies(self):&#10;            try:&#10;                f = open(self.session_folder + self.filename, 'r') &#10;                return f.read()&#10;            except FileNotFoundError:&#10;                return None&#10;&#10;        def set_saved_cookies(self, cookie_string):&#10;            if not os.path.exists(self.session_folder):&#10;                os.makedirs(self.session_folder)&#10;&#10;            with open(self.session_folder + self.filename,&quot;w+&quot;) as f:&#10;                f.write(cookie_string)&#10;&#10;        def empty_saved_cookies(self):&#10;            try:&#10;                os.remove(self.session_folder + self.filename)&#10;            except FileNotFoundError:&#10;                pass&#10;&#10;    class InitializerModel:&#10;&#10;        def __init__(self, props=None):&#10;&#10;            self._is_new = True&#10;            self._is_loaded = False&#10;            &quot;&quot;&quot;init data was empty&quot;&quot;&quot;&#10;            self._is_load_empty = True&#10;            self._is_fake = False&#10;            self._modified = None&#10;&#10;            &quot;&quot;&quot;Array of initialization data&quot;&quot;&quot;&#10;            self._data = {}&#10;&#10;            self.modified = time.time()&#10;&#10;            if props is not None and len(props) &gt; 0:&#10;                self._init(props)&#10;&#10;        def _init(self, props):&#10;            &quot;&quot;&quot;&#10;&#10;            :param props: props array&#10;            :return: None&#10;            &quot;&quot;&quot;&#10;            for key in props.keys():&#10;                try:&#10;                    self._init_properties_custom(props[key], key, props)&#10;                except AttributeError:&#10;                    self._data[key] = props[key]&#10;&#10;            self._is_new = False&#10;            self._is_loaded = True&#10;            self._is_load_empty = False&#10;&#10;    class Account(InitializerModel):&#10;&#10;        def __init__(self, props=None):&#10;            self.identifier = None&#10;            self.username = None&#10;            self.full_name = None&#10;            self.profile_pic_url = None&#10;            self.profile_pic_url_hd = None&#10;            self.biography = None&#10;            self.external_url = None&#10;            self.follows_count = 0&#10;            self.followed_by_count = 0&#10;            self.media_count = 0&#10;            self.is_private = False&#10;            self.is_verified = False&#10;            self.medias = []&#10;            self.blocked_by_viewer = False&#10;            self.country_block = False&#10;            self.followed_by_viewer = False&#10;            self.follows_viewer = False&#10;            self.has_channel = False&#10;            self.has_blocked_viewer = False&#10;            self.highlight_reel_count = 0&#10;            self.has_requested_viewer = False&#10;            self.is_business_account = False&#10;            self.is_joined_recently = False&#10;            self.business_category_name = None&#10;            self.business_email = None&#10;            self.business_phone_number = None&#10;            self.business_address_json = None&#10;            self.requested_by_viewer = False&#10;            self.connected_fb_page = None&#10;&#10;            super(Account, self).__init__(props)&#10;&#10;        def get_profile_picture_url(self):&#10;            try:&#10;                if not self.profile_pic_url_hd == '':&#10;                    return self.profile_pic_url_hd&#10;            except AttributeError:&#10;                try:&#10;                    return self.profile_pic_url&#10;                except AttributeError:&#10;                    return ''&#10;&#10;        def __str__(self):&#10;            string = f&quot;&quot;&quot;&#10;            Account info:&#10;            Id: {self.identifier}&#10;            Username: {self.username if hasattr(self, 'username') else '-'}&#10;            Full Name: {self.full_name if hasattr(self, 'full_name') else '-'}&#10;            Bio: {self.biography if hasattr(self, 'biography') else '-'}&#10;            Profile Pic Url: {self.get_profile_picture_url()}&#10;            External url: {self.external_url if hasattr(self, 'external_url') else '-'}&#10;            Number of published posts: {self.media_count if hasattr(self, 'media_count') else '-'}&#10;            Number of followers: {self.followed_by_count if hasattr(self, 'followed_by_count') else '-'}&#10;            Number of follows: {self.follows_count if hasattr(self, 'follows_count') else '-'}&#10;            Is private: {self.is_private if hasattr(self, 'is_private') else '-'}&#10;            Is verified: {self.is_verified if hasattr(self, 'is_verified') else '-'}&#10;            &quot;&quot;&quot;&#10;            return textwrap.dedent(string)&#10;&#10;        &quot;&quot;&quot;&#10;        * @param Media $media&#10;        * @return Account&#10;        &quot;&quot;&quot;&#10;        def add_media(self, media):&#10;            try:&#10;                self.medias.append(media)&#10;            except AttributeError:&#10;                raise AttributeError&#10;&#10;        def _init_properties_custom(self, value, prop, array):&#10;            &#10;            if prop == 'id':&#10;                self.identifier = value&#10;&#10;            standart_properties = [&#10;                'username',&#10;                'full_name',&#10;                'profile_pic_url',&#10;                'profile_pic_url_hd',&#10;                'biography',&#10;                'external_url',&#10;                'is_private',&#10;                'is_verified',&#10;                'blocked_by_viewer',&#10;                'country_block',&#10;                'followed_by_viewer',&#10;                'follows_viewer',&#10;                'has_channel',&#10;                'has_blocked_viewer', &#10;                'highlight_reel_count',&#10;                'has_requested_viewer',&#10;                'is_business_account',&#10;                'is_joined_recently',&#10;                'business_category_name',&#10;                'business_email',&#10;                'business_phone_number',&#10;                'business_address_json',&#10;                'requested_by_viewer',&#10;                'connected_fb_page'&#10;            ]&#10;            if prop in standart_properties:&#10;                self.__setattr__(prop, value)   &#10;            &#10;            if prop == 'edge_follow':&#10;                self.follows_count = array[prop]['count'] \&#10;                    if array[prop]['count'] is not None  else 0&#10;&#10;            if prop == 'edge_followed_by':&#10;                self.followed_by_count = array[prop]['count'] \&#10;                    if array[prop]['count'] is not None else 0&#10;&#10;            if prop == 'edge_owner_to_timeline_media':&#10;                self._init_media(array[prop])&#10;&#10;        def _init_media(self, array):&#10;            self.media_count = array['count'] if 'count' in array.keys() else 0 &#10;&#10;            try:&#10;                nodes = array['edges']&#10;            except:&#10;                return&#10;&#10;            if not self.media_count or isinstance(nodes, list):&#10;                return&#10;&#10;            for media_array in nodes:&#10;                media = Media(media_array['node'])&#10;                if isinstance(media, Media):&#10;                    self.add_media(media)&#10;                    &#10;    class Comment(InitializerModel):&#10;        &quot;&quot;&quot;&#10;        * @param $value&#10;        * @param $prop&#10;        &quot;&quot;&quot;&#10;&#10;        def __init__(self, props=None):&#10;            self.identifier = None&#10;            self.text = None&#10;            self.created_at = None&#10;            # Account object&#10;            self.owner = None&#10;&#10;            super(Comment, self).__init__(props)&#10;&#10;        def _init_properties_custom(self, value, prop, array):&#10;&#10;            if prop == 'id':&#10;                self.identifier = value&#10;&#10;            standart_properties = [&#10;                'created_at',&#10;                'text',&#10;            ]&#10;&#10;            if prop in standart_properties:&#10;                self.__setattr__(prop, value)&#10;&#10;            if prop == 'owner':&#10;                self.owner = Account(value)&#10;    class Media(InitializerModel):&#10;        TYPE_IMAGE = 'image'&#10;        TYPE_VIDEO = 'video'&#10;        TYPE_SIDECAR = 'sidecar'&#10;        TYPE_CAROUSEL = 'carousel'&#10;&#10;        def __init__(self, props=None):&#10;            self.identifier = None&#10;            self.short_code = None&#10;            self.created_time = 0&#10;            self.type = None&#10;            self.link = None&#10;            self.image_low_resolution_url = None&#10;            self.image_thumbnail_url = None&#10;            self.image_standard_resolution_url = None&#10;            self.image_high_resolution_url = None&#10;            self.square_images = []&#10;            self.carousel_media = []&#10;            self.caption = None&#10;            self.is_ad = False&#10;            self.video_low_resolution_url = None&#10;            self.video_standard_resolution_url = None&#10;            self.video_low_bandwidth_url = None&#10;            self.video_views = 0&#10;            self.video_url = None&#10;            # account object&#10;            self.owner = None&#10;            self.likes_count = 0&#10;            self.location_id = None&#10;            self.location_name = None&#10;            self.comments_count = 0&#10;            self.comments = []&#10;            self.has_more_comments = False&#10;            self.comments_next_page = None&#10;            self.location_slug = None&#10;&#10;            super(Media, self).__init__(props)&#10;&#10;&#10;        def __str__(self):&#10;            string = f&quot;&quot;&quot;&#10;            Media Info:&#10;            'Id: {self.identifier}&#10;            Shortcode: {self.short_code}&#10;            Created at: {self.created_time}&#10;            Caption: {self.caption}&#10;            Number of comments: {self.comments_count if hasattr(self,&#10;                                                                'commentsCount') else 0}&#10;            Number of likes: {self.likes_count}&#10;            Link: {self.link}&#10;            Hig res image: {self.image_high_resolution_url}&#10;            Media type: {self.type}&#10;            &quot;&quot;&quot;&#10;&#10;            return textwrap.dedent(string)&#10;&#10;        def _init_properties_custom(self, value, prop, arr):&#10;&#10;            if prop == 'id':&#10;                self.identifier = value&#10;&#10;            standart_properties = [&#10;                'type',&#10;                'link',&#10;                'thumbnail_src',&#10;                'caption',&#10;                'video_view_count',&#10;                'caption_is_edited',&#10;                'is_ad'&#10;            ]&#10;&#10;            if prop in standart_properties:&#10;                self.__setattr__(prop, value)&#10;&#10;            elif prop == 'created_time' or prop == 'taken_at_timestamp' or prop == 'date':&#10;                self.created_time = int(value)&#10;&#10;            elif prop == 'code':&#10;                self.short_code = value&#10;                self.link = get_media_page_link(self.short_code)&#10;&#10;            elif prop == 'comments':&#10;                self.comments_count = arr[prop]['count']&#10;            elif prop == 'likes':&#10;                self.likes_count = arr[prop]['count']&#10;&#10;            elif prop == 'display_resources':&#10;                medias_url = []&#10;                for media in value:&#10;                    medias_url.append(media['src'])&#10;&#10;                    if media['config_width'] == 640:&#10;                        self.image_thumbnail_url = media['src']&#10;                    elif media['config_width'] == 750:&#10;                        self.image_low_resolution_url = media['src']&#10;                    elif media['config_width'] == 1080:&#10;                        self.image_standard_resolution_url = media['src']&#10;&#10;            elif prop == 'display_src' or prop == 'display_url':&#10;                self.image_high_resolution_url = value&#10;                if self.type is None:&#10;                    self.type = Media.TYPE_IMAGE&#10;&#10;            elif prop == 'thumbnail_resources':&#10;                square_images_url = []&#10;                for square_image in value:&#10;                    square_images_url.append(square_image['src'])&#10;                self.square_images = square_images_url&#10;&#10;            elif prop == 'carousel_media':&#10;                self.type = Media.TYPE_CAROUSEL&#10;                self.carousel_media = []&#10;                for carousel_array in arr[&quot;carousel_media&quot;]:&#10;                    self.set_carousel_media(arr, carousel_array)&#10;&#10;            elif prop == 'video_views':&#10;                self.video_views = value&#10;                self.type = Media.TYPE_VIDEO&#10;&#10;            elif prop == 'videos':&#10;                self.video_low_resolution_url = arr[prop]['low_resolution']['url']&#10;                self.video_standard_resolution_url = \&#10;                arr[prop]['standard_resolution']['url']&#10;                self.video_low_bandwith_url = arr[prop]['low_bandwidth']['url']&#10;&#10;            elif prop == 'video_resources':&#10;                for video in value:&#10;                    if video['profile'] == 'MAIN':&#10;                        self.video_standard_resolution_url = video['src']&#10;                    elif video['profile'] == 'BASELINE':&#10;                        self.video_low_resolution_url = video['src']&#10;                        self.video_low_bandwith_url = video['src']&#10;&#10;            elif prop == 'location' and value is not None:&#10;                self.location_id = arr[prop]['id']&#10;                self.location_name = arr[prop]['name']&#10;                self.location_slug = arr[prop]['slug']&#10;&#10;            elif prop == 'user' or prop == 'owner':&#10;                self.owner = Account(arr[prop])&#10;&#10;            elif prop == 'is_video':&#10;                if bool(value):&#10;                    self.type = Media.TYPE_VIDEO&#10;&#10;            elif prop == 'video_url':&#10;                self.video_standard_resolution_url = value&#10;&#10;            elif prop == 'shortcode':&#10;                self.short_code = value&#10;                self.link = get_media_page_link(self.short_code)&#10;&#10;            elif prop == 'edge_media_to_comment':&#10;                try:&#10;                    self.comments_count = int(arr[prop]['count'])&#10;                except KeyError:&#10;                    pass&#10;                try:&#10;                    edges = arr[prop]['edges']&#10;&#10;                    for comment_data in edges:&#10;                        self.comments.append(Comment(comment_data['node']))&#10;                except KeyError:&#10;                    pass&#10;                try:&#10;                    self.has_more_comments = bool(&#10;                        arr[prop]['page_info']['has_next_page'])&#10;                except KeyError:&#10;                    pass&#10;                try:&#10;                    self.comments_next_page = str(&#10;                        arr[prop]['page_info']['end_cursor'])&#10;                except KeyError:&#10;                    pass&#10;&#10;            elif prop == 'edge_media_preview_like':&#10;                self.likes_count = arr[prop]['count']&#10;            elif prop == 'edge_liked_by':&#10;                self.likes_count = arr[prop]['count']&#10;&#10;            elif prop == 'edge_media_to_caption':&#10;                try:&#10;                    self.caption = arr[prop]['edges'][0]['node']['text']&#10;                except (KeyError, IndexError):&#10;                    pass&#10;&#10;            elif prop == 'edge_sidecar_to_children':&#10;                pass&#10;                &#10;            elif prop == '__typename':&#10;                if value == 'GraphImage':&#10;                    self.type = Media.TYPE_IMAGE&#10;                elif value == 'GraphVideo':&#10;                    self.type = Media.TYPE_VIDEO&#10;                elif value == 'GraphSidecar':&#10;                    self.type = Media.TYPE_SIDECAR&#10;&#10;    class Instagram:&#10;        HTTP_NOT_FOUND = 404&#10;        HTTP_OK = 200&#10;        HTTP_FORBIDDEN = 403&#10;        HTTP_BAD_REQUEST = 400&#10;        MAX_COMMENTS_PER_REQUEST = 300&#10;        PAGING_TIME_LIMIT_SEC = 1800&#10;        PAGING_DELAY_MINIMUM_MICROSEC = 1000000  # 1 sec min delay to simulate browser&#10;        PAGING_DELAY_MAXIMUM_MICROSEC = 3000000  # 3 sec max delay to simulate browser&#10;&#10;        instance_cache = None&#10;&#10;        def __init__(self, sleep_between_requests=0):&#10;            self.__req = HTMLSession()&#10;            self.paging_time_limit_sec = Instagram.PAGING_TIME_LIMIT_SEC&#10;            self.paging_delay_minimum_microsec = Instagram.PAGING_DELAY_MINIMUM_MICROSEC&#10;            self.paging_delay_maximum_microsec = Instagram.PAGING_DELAY_MAXIMUM_MICROSEC&#10;            self.session_username = None&#10;            self.session_password = None&#10;            self.cookie=None&#10;            self.user_session = None&#10;            self.rhx_gis = None&#10;            self.sleep_between_requests = sleep_between_requests&#10;            self.user_agent = 'Instagram 126.0.0.25.121 Android (23/6.0.1; 320dpi; 720x1280; samsung; SM-A310F; a3xelte; samsungexynos7580; en_GB; 110937453)'&#10;&#10;        def set_cookies(self,cookie):&#10;            cj = http.cookiejar.MozillaCookieJar(cookie)&#10;            cj.load()&#10;            cookie = requests.utils.dict_from_cookiejar(cj)&#10;            self.cookie=cookie&#10;            self.user_session = cookie&#10;&#10;        def with_credentials(self, username, password, session_folder=None):&#10;            &quot;&quot;&quot;&#10;            param string username&#10;            param string password&#10;            param null sessionFolder&#10;&#10;            return Instagram&#10;            &quot;&quot;&quot;&#10;            Instagram.instance_cache = None&#10;&#10;            if not session_folder:&#10;                cwd = os.getcwd()&#10;                session_folder = cwd + os.path.sep + 'sessions' + os.path.sep&#10;&#10;            if isinstance(session_folder, str):&#10;&#10;                Instagram.instance_cache = CookieSessionManager(&#10;                    session_folder, slugify(username) + '.txt')&#10;&#10;            else:&#10;                Instagram.instance_cache = session_folder&#10;&#10;            Instagram.instance_cache.empty_saved_cookies()&#10;&#10;            self.session_username = username&#10;            self.session_password = password&#10;&#10;        def get_user_agent(self):&#10;            return self.user_agent&#10;&#10;        def set_user_agent(self, user_agent):&#10;            self.user_agent = user_agent&#10;&#10;        def generate_headers(self, session, gis_token=None):&#10;            &quot;&quot;&quot;&#10;            :param session: user session dict&#10;            :param gis_token: a token used to be verified by instagram in header&#10;            :return: header dict&#10;            &quot;&quot;&quot;&#10;            headers = {}&#10;            if session is not None:&#10;                cookies = ''&#10;&#10;                for key in session.keys():&#10;                    cookies += f&quot;{key}={session[key]}; &quot;&#10;&#10;                csrf = session['x-csrftoken'] if session['csrftoken'] is None else \&#10;                    session['csrftoken']&#10;&#10;                headers = {&#10;                    'cookie': cookies,&#10;                    'referer': BASE_URL + '/',&#10;                    'x-csrftoken': csrf&#10;                }&#10;&#10;            if self.user_agent is not None:&#10;                headers['user-agent'] = self.user_agent&#10;&#10;                if gis_token is not None:&#10;                    headers['x-instagram-gis'] = gis_token&#10;&#10;            return headers&#10;&#10;        def __generate_gis_token(self, variables):&#10;            &quot;&quot;&quot;&#10;            :param variables: a dict used to  generate_gis_token&#10;            :return: a token used to be verified by instagram&#10;            &quot;&quot;&quot;&#10;            rhx_gis = self.__get_rhx_gis() if self.__get_rhx_gis() is not None else 'NULL'&#10;            string_to_hash = ':'.join([rhx_gis, json.dumps(variables, separators=(',', ':')) if isinstance(variables, dict) else variables])&#10;            return hashlib.md5(string_to_hash.encode('utf-8')).hexdigest()&#10;&#10;        def __get_rhx_gis(self):&#10;            &quot;&quot;&quot;&#10;            :return: a string to generate gis_token&#10;            &quot;&quot;&quot;&#10;            if self.rhx_gis is None:&#10;                try:&#10;                    shared_data = self.__get_shared_data_from_page()&#10;                except Exception as _:&#10;                    raise InstagramException('Could not extract gis from page')&#10;&#10;                if 'rhx_gis' in shared_data.keys():&#10;                    self.rhx_gis = shared_data['rhx_gis']&#10;                else:&#10;                    self.rhx_gis = None&#10;&#10;            return self.rhx_gis&#10;&#10;        def __get_mid(self):&#10;            &quot;&quot;&quot;manually fetches the machine id from graphQL&quot;&quot;&quot;&#10;            time.sleep(self.sleep_between_requests)&#10;            response = self.__req.get('https://www.instagram.com/web/__mid/')&#10;&#10;            if response.status_code != Instagram.HTTP_OK:&#10;                raise InstagramException.default(response.text,&#10;                                                response.status_code)&#10;&#10;            return response.text&#10;&#10;        def __get_shared_data_from_page(self, url=BASE_URL):&#10;            &quot;&quot;&quot;&#10;            :param url: the requested url&#10;            :return: a dict extract from page&#10;            &quot;&quot;&quot;&#10;            url = url.rstrip('/') + '/'&#10;            time.sleep(self.sleep_between_requests)&#10;            response = self.__req.get(url, headers=self.generate_headers(&#10;                self.user_session))&#10;&#10;            if Instagram.HTTP_NOT_FOUND == response.status_code:&#10;                raise InstagramException(f&quot;Page {url} not found&quot;)&#10;&#10;            if not Instagram.HTTP_OK == response.status_code:&#10;                raise InstagramException.default(response.text,&#10;                                                response.status_code)&#10;&#10;            return Instagram.extract_shared_data_from_body(response.text)&#10;&#10;        @staticmethod&#10;        def extract_shared_data_from_body(body):&#10;            &quot;&quot;&quot;&#10;            :param body: html string from a page&#10;            :return: a dict extract from page&#10;            &quot;&quot;&quot;&#10;            array = re.findall(r'_sharedData = .*?;&lt;/script&gt;', body)&#10;            if len(array) &gt; 0:&#10;                raw_json = array[0][len(&quot;_sharedData =&quot;):-len(&quot;;&lt;/script&gt;&quot;)]&#10;&#10;                return json.loads(raw_json)&#10;&#10;            return None&#10;&#10;        &#10;&#10;        def get_media_comments_by_code(self, code, count=10, max_id=''):&#10;            &quot;&quot;&quot;&#10;            :param code: media code&#10;            :param count: the number of how many comments you want to get&#10;            :param max_id: used to paginate&#10;            :return: Comment List&#10;            &quot;&quot;&quot;&#10;            abc = 0&#10;            comments = []&#10;            index = 0&#10;            has_previous = True&#10;&#10;            while has_previous and index &lt; count:&#10;                number_of_comments_to_receive = 0&#10;                if count - index &gt; Instagram.MAX_COMMENTS_PER_REQUEST:&#10;                    number_of_comments_to_receive = Instagram.MAX_COMMENTS_PER_REQUEST&#10;                else:&#10;                    number_of_comments_to_receive = count - index&#10;&#10;                variables = {&#10;                    &quot;shortcode&quot;: str(code),&#10;                    &quot;first&quot;: str(number_of_comments_to_receive),&#10;                    &quot;after&quot;: '' if not max_id else max_id&#10;                }&#10;&#10;                comments_url = get_comments_before_comments_id_by_code(&#10;                    variables)&#10;&#10;                time.sleep(20)&#10;                response = self.__req.get(comments_url,&#10;                                        headers=self.generate_headers(&#10;                                            self.user_session,&#10;                                            self.__generate_gis_token(variables)))&#10;&#10;                if not response.status_code == Instagram.HTTP_OK:&#10;                    print(response.status_code)&#10;                    print(response.text)&#10;                    break&#10;                    &#10;                jsonResponse = response.json()&#10;&#10;                nodes = jsonResponse['data']['shortcode_media']['edge_media_to_parent_comment']['edges']&#10;&#10;                for commentArray in nodes:&#10;                    comment = Comment(commentArray['node'])&#10;                    comments.append(comment)&#10;                    index += 1&#10;&#10;                has_previous = jsonResponse['data']['shortcode_media']['edge_media_to_parent_comment']['page_info']['has_next_page']&#10;&#10;                number_of_comments = jsonResponse['data']['shortcode_media']['edge_media_to_parent_comment']['count']&#10;                if count &gt; number_of_comments:&#10;                    count = number_of_comments&#10;&#10;                max_id = jsonResponse['data']['shortcode_media']['edge_media_to_parent_comment']['page_info']['end_cursor']&#10;&#10;                abc +=1&#10;                print('total request amount: ',abc)&#10;                print('Kommentare erfasst: ',len(comments))&#10;                if len(nodes) == 0:&#10;                    break&#10;&#10;            data = {}&#10;            data['next_page'] = max_id&#10;            data['comments'] = comments&#10;            return data&#10;        &#10;        def is_logged_in(self, session):&#10;                &quot;&quot;&quot;&#10;                :param session: session dict&#10;                :return: bool&#10;                &quot;&quot;&quot;&#10;                if self.cookie!=None:&#10;                    return True&#10;&#10;                if session is None or 'sessionid' not in session.keys():&#10;                    return False&#10;&#10;&#10;                session_id = session['sessionid']&#10;                csrf_token = session['csrftoken']&#10;&#10;                headers = {&#10;                    'cookie': f&quot;ig_cb=1; csrftoken={csrf_token}; sessionid={session_id};&quot;,&#10;                    'referer': BASE_URL + '/',&#10;                    'x-csrftoken': csrf_token,&#10;                    'X-CSRFToken': csrf_token,&#10;                    'user-agent': self.user_agent,&#10;                }&#10;&#10;                time.sleep(self.sleep_between_requests)&#10;                response = self.__req.get(BASE_URL, headers=headers)&#10;&#10;                if not response.status_code == Instagram.HTTP_OK:&#10;                    return False&#10;&#10;                cookies = response.cookies.get_dict()&#10;&#10;&#10;                if cookies is None or not 'ds_user_id' in cookies.keys():&#10;                    return False&#10;&#10;                return True&#10;&#10;        def login(self, force=False, two_step_verificator=None):&#10;            &quot;&quot;&quot;support_two_step_verification true works only in cli mode - just run login in cli mode - save cookie to file and use in any mode&#10;            :param force: true will refresh the session&#10;            :param two_step_verificator: true will need to do verification when an account goes wrong&#10;            :return: headers dict&#10;            &quot;&quot;&quot;&#10;            if self.session_username is None or self.session_password is None:&#10;                raise InstagramException(&quot;User credentials not provided&quot;)&#10;&#10;            session = json.loads(&#10;                Instagram.instance_cache.get_saved_cookies()) if Instagram.instance_cache.get_saved_cookies() != None else None&#10;&#10;            if force or not self.is_logged_in(session):&#10;                time.sleep(self.sleep_between_requests)&#10;                response = self.__req.get(BASE_URL)&#10;                if not response.status_code == Instagram.HTTP_OK:&#10;                    raise InstagramException.default(response.text,&#10;                                                    response.status_code)&#10;&#10;                match = re.findall(r'&quot;csrf_token&quot;:&quot;(.*?)&quot;', response.text)&#10;&#10;                if len(match) &gt; 0:&#10;                    csrfToken = match[0]&#10;&#10;                cookies = response.cookies.get_dict()&#10;                &#10;                mid = self.__get_mid()&#10;&#10;                headers = {&#10;                    'cookie': f&quot;ig_cb=1; csrftoken={csrfToken}; mid={mid};&quot;,&#10;                    'referer': BASE_URL + '/',&#10;                    'x-csrftoken': csrfToken,&#10;                    'X-CSRFToken': csrfToken,&#10;                    'user-agent': self.user_agent,&#10;                }&#10;                payload = {'username': self.session_username,&#10;                        'enc_password': f&quot;#PWD_INSTAGRAM_BROWSER:0:{int(time.time())}:{self.session_password}&quot;}&#10;                response = self.__req.post(LOGIN_URL, data=payload,&#10;                                        headers=headers)&#10;&#10;                if not response.status_code == Instagram.HTTP_OK:&#10;                    if (&#10;                            response.status_code == Instagram.HTTP_BAD_REQUEST):&#10;                        print('checkpoint required')&#10;&#10;                    elif response.status_code is not None and response.text is not None:&#10;                        raise InstagramException(&#10;                            f'Response code is {response.status_code}. Body: {response.text} Something went wrong. Please report issue.',&#10;                            response.status_code)&#10;                    else:&#10;                        raise InstagramException(&#10;                            'Something went wrong. Please report issue.',&#10;                            response.status_code)&#10;                elif not response.json()['authenticated']:&#10;                    raise InstagramException('User credentials are wrong.')&#10;&#10;                cookies = response.cookies.get_dict()&#10;&#10;                cookies['mid'] = mid&#10;                Instagram.instance_cache.set_saved_cookies(json.dumps(cookies, separators=(',', ':')))&#10;&#10;                self.user_session = cookies&#10;&#10;            else:&#10;                self.user_session = session&#10;&#10;            return self.generate_headers(self.user_session)&#10;&#10;    instagram = Instagram()&#10;    instagram.with_credentials('%{user}', '%{pass}')&#10;    instagram.login()&#10;   &#10;    list_text = []&#10;    list_owner = []&#10;&#10;    comments = instagram.get_media_comments_by_code('%{postcode}',%{amount})&#10;&#10;    for comment in comments['comments']:&#10;        list_text.append(comment.text)&#10;        list_owner.append(comment.owner.username)&#10;    &#10;    for i in range(len(list_text)):&#10;        list_text[i]=demojize(list_text[i],'%{lang}',delimiters=(&quot; &quot;, &quot; &quot;))&#10;    comment_df= pd.DataFrame()&#10;    comment_df['username'] = list_owner&#10;    comment_df['comment'] = list_text&#10;&#10;    return comment_df"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="false"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="conda_environment" value="base"/>
        <parameter key="use_macros" value="true"/>
      </operator>
      <operator activated="true" class="multiply" compatibility="9.7.002" expanded="true" height="124" name="Multiply" width="90" x="313" y="187"/>
      <operator activated="true" class="write_csv" compatibility="9.7.002" expanded="true" height="82" name="Write CSV" width="90" x="447" y="238">
        <parameter key="csv_file" value="/Users/danielkinne/test.csv"/>
        <parameter key="column_separator" value=";"/>
        <parameter key="write_attribute_names" value="true"/>
        <parameter key="quote_nominal_values" value="true"/>
        <parameter key="format_date_attributes" value="true"/>
        <parameter key="append_to_file" value="false"/>
        <parameter key="encoding" value="SYSTEM"/>
        <description align="center" color="transparent" colored="false" width="126">specify the path for the target file&lt;br/&gt;</description>
      </operator>
      <operator activated="true" class="store" compatibility="9.7.002" expanded="true" height="68" name="Store" width="90" x="447" y="136">
        <parameter key="repository_entry" value="../data/ig-comments-noemo"/>
      </operator>
      <connect from_op="Postcode from URL" from_port="through 1" to_op="Execute Python" to_port="input 1"/>
      <connect from_op="Username" from_port="through 1" to_op="Execute Python" to_port="input 2"/>
      <connect from_op="Password" from_port="through 1" to_op="Execute Python" to_port="input 3"/>
      <connect from_op="Amount of Comments to download" from_port="through 1" to_op="Execute Python" to_port="input 4"/>
      <connect from_op="Language of Emoji Translations" from_port="through 1" to_op="Execute Python" to_port="input 5"/>
      <connect from_op="Execute Python" from_port="output 1" to_op="Multiply" to_port="input"/>
      <connect from_op="Multiply" from_port="output 1" to_port="result 1"/>
      <connect from_op="Multiply" from_port="output 2" to_op="Store" to_port="input"/>
      <connect from_op="Multiply" from_port="output 3" to_op="Write CSV" to_port="input"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <portSpacing port="sink_result 2" spacing="0"/>
    </process>
  </operator>
</process>
